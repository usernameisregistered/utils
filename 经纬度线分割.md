##二维
```
析源代码为下
// 20037508.34  
// 球面墨卡托投影
// 地图投影通常使用一个EPSG代码表示，如最常用的EPSG：4326是经纬度投影。球面墨卡托的官方代码是EPSG:3857，非官方的代码EPSG:900913。
// 特别地，大多数球面墨卡托表示地球的范围：经度(-180~180)，纬度(-85.0511,85.0511)。换算成米就是（-20037508.34，-20037508.34，20037508.34，20037508.34），刚好为一个正方形，
/**
 * 
 * @param {Array} vectors 坐标点集合
 * @param {number} totalPoint 表示分离后的总共的点位个数 每段分离后的点位个数不一致 每段所用时间不一致 表示车辆进行匀速的运动 
 * @returns 
 */
export function splitCroods(croods, totalPoint = 10000) {
    let result = [];
    let distances = calcDistance(croods)
    let steps = [];
    let totlaDistance = distances.reduce((total, num) => total += num * 1)
    let step = totalPoint / totlaDistance
    for (let i = 0; i < croods.length - 1; i++) {
        steps.push(Math.round(distances[i] * step))
    }
    for (let i = 0; i < croods.length - 1; i++) {
        let currentStep = steps[i];
        let start = croods[i]
        let end = croods[i + 1]
        // let lngDistance = end.longitude - start.longitude
        // let latDistance = end.latitude - start.latitude
        for (let j = 0; j < currentStep; j++) {
            let newCroods = {};
            // if (lngDistance > 0) {
            //     newCroods.longitude = start.longitude + j * lngDistance / currentStep
            // } else {
            //     if (start.longitude > 0) {
            //         newCroods.longitude = start.longitude + j * lngDistance / currentStep
            //     } else {
            //         newCroods.longitude = start.longitude - j * lngDistance / currentStep
            //     }
            // }
            // if (latDistance > 0) {
            //     newCroods.latitude = start.latitude + j * latDistance / currentStep
            // } else {
            //     if (start.latitude > 0) {
            //         newCroods.latitude = start.latitude - j * latDistance / currentStep
            //     } else {
            //         newCroods.latitude = start.latitude + j * latDistance / currentStep
            //     }
            // }
            newCroods.longitude = (j * end.longitude + (currentStep - j) * start.longitude) / currentStep
            newCroods.latitude = (j * end.latitude + (currentStep - j) * start.latitude) / currentStep
            result.push(newCroods)
        }
    }
    return result
}
function calcDistance(croods) {
    let result = [];
    for (let i = 0; i < croods.length - 1; i++) {
        let a = lngLat2Mercator(croods[i])
        let b = lngLat2Mercator(croods[i + 1])
        let d = Math.sqrt(Math.pow(a.longitude - b.longitude, 2) + Math.pow(a.latitude - b.latitude, 2))
        result.push(d)
    }
    return result
}

function lngLat2Mercator(lngLat) {
    let lng = 20037508.34 * lngLat.longitude / 180;
    let lat = Math.log(Math.tan((90 + lngLat.latitude) * Math.PI / 360)) / (Math.PI / 180);
    lat = 20037508.34 * lngLat.latitude / 180;
    return { longitude: lng, latitude: lat }
}
```

## 三维

```
export function getPointsBySegment(vectors, segment) {
    let distances = [];
    let totalDistance = 0;
    let steps = [];
    let result = [];
    for (let i = 0; i < vectors.length - 1; i++) {
        let distance = getDistance(vectors[i], vectors[i + 1]);
        totalDistance += distance;
        distances.push(distance);
    }
    let step = segment / totalDistance
    for (let i = 0; i < vectors.length - 1; i++) {
        steps.push(Math.round(distances[i] * step))
    }
    for (let j = 0; j < vectors.length - 1; j++) {
        let points = getPointsVectorBySegment(vectors[j], vectors[j + 1], steps[j]);
        points.unshift([vectors[j].x, vectors[j].y, vectors[j].z]);
        if (j === vectors.length - 2) {
            points.push([vectors[j + 1].x, vectors[j + 1].y, vectors[j + 1].z]);
        }
        result.push(points);
    }
    let croods = []
    result.forEach((points) => {
        points.forEach((item) => {
            croods.push(vector3ToSphericalCoords2(item))
        });
    });
    return croods
}

function vector3ToSphericalCoords2(vector) {
    const phi = Math.acos(vector[1] / Math.sqrt(vector[0] * vector[0] + vector[1] * vector[1] + vector[2] * vector[2]));
    const theta = Math.atan2(vector[0], vector[2]);
    let longitude = theta < 0 ? -theta : Math.PI * 2 - theta;
    let latitude = Math.PI / 2 - phi;
    return { _lon: longitude, _lat: latitude };
}

function getDistance(v1, v2) {
    return Math.sqrt(Math.pow((v2.x - v1.x), 2) + Math.pow((v2.y - v1.y), 2) + Math.pow((v2.z - v1.z), 2));
}

function getPointsVectorBySegment(start, end, segment) {
    let midPoints = [];
    for (let i = 1; i < segment; i++) {
        let x = (i * end.x + (segment - i) * start.x) / segment;
        let y = (i * end.y + (segment - i) * start.y) / segment;
        let z = (i * end.z + (segment - i) * start.z) / segment;
        midPoints.push([x, y, z]);
    }
    return midPoints;
}

```
